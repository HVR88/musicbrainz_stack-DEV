#!/bin/bash

set -e -o pipefail -u

SCRIPT_NAME=$(basename "$0")

HELP=$(cat <<'EOH'
Usage: upgrade-volumes [--dry-run] [--cleanup]

Migrate legacy mbms_plus_* volumes to limbo_* volumes.
- Creates target volumes if missing.
- Copies data (source -> target) and leaves sources intact.
- For Limbo init-state volumes, merges multiple legacy names into
  a single target volume; last one copied wins on conflicts.

Recommended: stop the stack before running.
EOH
)

echo
echo "Limbo MBMS_PLUS Volume Migration"

DRY_RUN=0
CLEANUP=0
if [[ $# -gt 0 ]]; then
  case "$1" in
    -h|--help)
      echo "$HELP"
      exit 0
      ;;
    --dry-run)
      DRY_RUN=1
      ;;
    --cleanup)
      CLEANUP=1
      ;;
    *)
      echo >&2 "$SCRIPT_NAME: unrecognized argument: $1"
      echo >&2 "Try '$SCRIPT_NAME --help' for usage."
      exit 64
      ;;
  esac
fi

DOCKER_CMD=${DOCKER_CMD:-docker}

if command -v docker >/dev/null 2>&1; then
  :
else
  echo >&2 "$SCRIPT_NAME: docker not found in PATH"
  exit 127
fi

COMPOSE_CMD=${DOCKER_COMPOSE_CMD:-${DOCKER_CMD} compose}
if [ -f docker-compose.yml ]; then
  if $COMPOSE_CMD ps --status running -q >/dev/null 2>&1; then
    if [ -n "$($COMPOSE_CMD ps --status running -q)" ]; then
      echo >&2 "Error: Docker stack appears to be running."
      echo >&2 "Please stop the stack (docker compose down) and re-run this script."
      exit 1
    fi
  fi
fi

if [ -n "$($DOCKER_CMD ps --format '{{.Names}}' | grep -E '(^|_)mbms_plus|(^|_)limbo' || true)" ]; then
  echo >&2 "Error: Detected running containers that look like MBMS/Limbo."
  echo >&2 "Please stop the stack and re-run this script."
  exit 1
fi

MARKER_DIR=".mbms-migration"
mkdir -p "$MARKER_DIR"

MIGRATED_TARGETS=()
MIGRATED_SOURCES=()

write_marker() {
  local src=$1
  local dst=$2
  local marker="$MARKER_DIR/${dst}.done"
  local ts
  ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "${ts} ${src} -> ${dst}" > "$marker"
}

volume_exists() {
  $DOCKER_CMD volume inspect "$1" >/dev/null 2>&1
}

declare -A VOLUME_SIZES
load_volume_sizes() {
  local df_output
  if ! df_output=$($DOCKER_CMD system df -v 2>/dev/null); then
    return 0
  fi
  echo "$df_output" | awk '
    $1=="VOLUME" && $2=="NAME" {invol=1; next}
    invol && NF==0 {exit}
    invol && NF>=3 {print $1, $3}
  ' | while read -r name size; do
    VOLUME_SIZES["$name"]="$size"
  done
}

volume_size() {
  local name=$1
  if [[ -n "${VOLUME_SIZES[$name]:-}" ]]; then
    echo "${VOLUME_SIZES[$name]}"
  else
    echo "unknown"
  fi
}

size_to_bytes() {
  local s=$1
  local num unit
  num=${s%[A-Za-z]*}
  unit=${s##$num}
  case "$unit" in
    B|"") echo "$num" ;;
    kB) awk -v n="$num" 'BEGIN{printf "%.0f", n*1000}' ;;
    KB) awk -v n="$num" 'BEGIN{printf "%.0f", n*1000}' ;;
    MB) awk -v n="$num" 'BEGIN{printf "%.0f", n*1000*1000}' ;;
    GB) awk -v n="$num" 'BEGIN{printf "%.0f", n*1000*1000*1000}' ;;
    TB) awk -v n="$num" 'BEGIN{printf "%.0f", n*1000*1000*1000*1000}' ;;
    *) echo "" ;;
  esac
}

bytes_to_human() {
  local b=$1
  if [ -z "$b" ]; then
    echo "unknown"
    return
  fi
  awk -v b="$b" 'BEGIN{
    if (b>=1e12) printf "%.2f TB", b/1e12;
    else if (b>=1e9) printf "%.2f GB", b/1e9;
    else if (b>=1e6) printf "%.2f MB", b/1e6;
    else if (b>=1e3) printf "%.2f kB", b/1e3;
    else printf "%d B", b;
  }'
}

create_volume() {
  local name=$1
  if volume_exists "$name"; then
    return 0
  fi
  if [[ $DRY_RUN -eq 1 ]]; then
    echo "DRY-RUN: $DOCKER_CMD volume create $name"
  else
    $DOCKER_CMD volume create "$name" >/dev/null
  fi
}

copy_volume() {
  local src=$1
  local dst=$2

  echo
  echo "Starting copy: $src -> $dst"

  if ! volume_exists "$src"; then
    echo "Skip: source volume not found: $src"
    return 0
  fi

  if volume_exists "$dst"; then
    if [[ $DRY_RUN -eq 1 ]]; then
      echo "DRY-RUN: $DOCKER_CMD volume rm $dst"
    else
      echo "Replacing existing target volume: $dst"
      $DOCKER_CMD volume rm "$dst" >/dev/null
    fi
  fi
  create_volume "$dst"

  if [[ $DRY_RUN -eq 1 ]]; then
    echo "DRY-RUN: copy $src -> $dst"
    return 0
  fi

  run_with_heartbeat "Copying $src -> $dst" \
    $DOCKER_CMD run --rm \
      -v "$src":/from \
      -v "$dst":/to \
      alpine sh -c "cd /from && tar -cf - . | tar -xpf - -C /to"

  write_marker "$src" "$dst"
  MIGRATED_TARGETS+=("$dst")
  MIGRATED_SOURCES+=("$src")
}

# Report what will be migrated
echo
echo "Scanning for volumes to migrate..."

load_volume_sizes

FOUND=()
FOUND_SOURCES=()
TARGETS_TO_REPLACE=()
TOTAL_BYTES=""
for pair in "mbms_plus_pgdata:limbo_pgdata" \
            "mbms_plus_mqdata:limbo_mqdata" \
            "mbms_plus_dbdump:limbo_dbdump" \
            "mbms_plus_solrdata:limbo_solrdata" \
            "mbms_plus_solrdump:limbo_solrdump"; do
  src=${pair%%:*}
  dst=${pair##*:}
  if volume_exists "$src"; then
    FOUND+=("$src ($(volume_size "$src")) -> $dst")
    size_b=$(size_to_bytes "$(volume_size "$src")")
    if [ -n "$size_b" ]; then
      if [ -z "$TOTAL_BYTES" ]; then TOTAL_BYTES=0; fi
      TOTAL_BYTES=$(awk -v a="$TOTAL_BYTES" -v b="$size_b" 'BEGIN{printf "%.0f", a+b}')
    fi
    if volume_exists "$dst"; then
      TARGETS_TO_REPLACE+=("$dst")
    fi
  fi
done

INIT_SOURCES=(
  "mbms_plus_limbo_init_state"
  "mbms_plus_lmbridge-init-state"
  "mbms_plus_lmbridge_init_state"
)
INIT_TARGET="limbo_bridge_init_state"
for src in "${INIT_SOURCES[@]}"; do
  if volume_exists "$src"; then
    FOUND+=("$src ($(volume_size "$src")) -> $INIT_TARGET")
    size_b=$(size_to_bytes "$(volume_size "$src")")
    if [ -n "$size_b" ]; then
      if [ -z "$TOTAL_BYTES" ]; then TOTAL_BYTES=0; fi
      TOTAL_BYTES=$(awk -v a="$TOTAL_BYTES" -v b="$size_b" 'BEGIN{printf "%.0f", a+b}')
    fi
    if volume_exists "$INIT_TARGET"; then
      TARGETS_TO_REPLACE+=("$INIT_TARGET")
    fi
  fi
done

if [ ${#FOUND[@]} -eq 0 ]; then
  echo "No matching mbms_plus_* volumes found. Nothing to migrate."
  exit 0
fi

if [ -n "$TOTAL_BYTES" ]; then
  echo "Approx total size: $(bytes_to_human "$TOTAL_BYTES")"
fi
echo
printf '%s\n' "Volumes to migrate:" "${FOUND[@]}"

if [ ${#TARGETS_TO_REPLACE[@]} -gt 0 ]; then
  echo
  echo "Existing target volumes will be replaced:"
  printf '%s\n' "${TARGETS_TO_REPLACE[@]}"
  echo "These will be removed before copying."
fi

echo
echo "Note: This can take from a few minutes to hours depending on volume size."
echo "Expect around 40 minutes on nvme/ssd."
echo "You'll need a little bit more free disk space than the total size of the"
echo "volumes being copied."
echo "Do NOT stop the process once it starts. If you must stop it, re-run this"
echo "script and it will replace any partially copied target volumes."
echo

if [[ $DRY_RUN -eq 0 ]]; then
  read -r -p "Continue? [y/N] " confirm
  case "$confirm" in
    y|Y|yes|YES) ;;
    *) echo "Cancelled."; exit 0 ;;
  esac
fi

run_with_heartbeat() {
  local msg=$1
  shift
  local hb_pid=
  (
    while true; do
      echo "  [$(date '+%Y-%m-%d %H:%M:%S')] $msg..."
      sleep 30
    done
  ) &
  hb_pid=$!
  "$@"
  local status=$?
  kill "$hb_pid" >/dev/null 2>&1 || true
  wait "$hb_pid" >/dev/null 2>&1 || true
  return $status
}

# Standard mbms_plus_* volumes -> limbo_*
PAIRS=(
  "mbms_plus_pgdata:limbo_pgdata"
  "mbms_plus_mqdata:limbo_mqdata"
  "mbms_plus_dbdump:limbo_dbdump"
  "mbms_plus_solrdata:limbo_solrdata"
  "mbms_plus_solrdump:limbo_solrdump"
)

for pair in "${PAIRS[@]}"; do
  src=${pair%%:*}
  dst=${pair##*:}
  copy_volume "$src" "$dst"
done

# Merge legacy Limbo init-state volumes into a single fixed target.
INIT_TARGET="limbo_bridge_init_state"
INIT_SOURCES=(
  "mbms_plus_limbo_init_state"
  "mbms_plus_lmbridge-init-state"
  "mbms_plus_lmbridge_init_state"
)

for src in "${INIT_SOURCES[@]}"; do
  copy_volume "$src" "$INIT_TARGET"
done

echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ") Migration complete" > "$MARKER_DIR/MIGRATION_COMPLETE"

if [[ $CLEANUP -eq 1 ]]; then
  echo
  echo "Cleanup requested. Verifying markers before removing source volumes..."
  missing=0
  for dst in "${MIGRATED_TARGETS[@]}"; do
    if [ ! -s "$MARKER_DIR/${dst}.done" ]; then
      echo "Missing marker: $MARKER_DIR/${dst}.done"
      missing=1
    fi
  done
  if [ $missing -ne 0 ]; then
    echo "Cleanup skipped: missing marker(s)."
  else
    echo "All markers present. Removing source volumes..."
    for src in "${MIGRATED_SOURCES[@]}"; do
      if [[ $DRY_RUN -eq 1 ]]; then
        echo "DRY-RUN: $DOCKER_CMD volume rm $src"
      else
        $DOCKER_CMD volume rm "$src" >/dev/null 2>&1 || true
      fi
    done
    echo "Cleanup complete."
  fi
fi

echo "Done."
