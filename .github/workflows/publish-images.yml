name: Publish Images

on:
  workflow_dispatch:
    inputs:
      expected_version:
        description: "Expected VERSION (must match VERSION file exactly)"
        required: true
        type: string
      channel:
        description: "Publish channel (stable|test)"
        required: true
        default: "stable"
        type: string
      deploy_target:
        description: "Deploy target (limbo|mbms|both)"
        required: true
        default: "both"
        type: string

permissions:
  contents: read
  packages: write

jobs:
  publish-dockerhub:
    name: Publish to Docker Hub
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN_MBMS: ${{ secrets.DOCKERHUB_TOKEN_MBMS }}
      IMAGE_REGISTRY: docker.io
      IMAGE_REPO_PREFIX: limbo
      DOCKER_CHANNEL_TAG: ${{ inputs.channel == 'test' && 'test' || 'latest' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: db
            context: build/postgres-prebuilt
            dockerfile: build/postgres-prebuilt/Dockerfile
          - name: musicbrainz
            context: .
            dockerfile: build/musicbrainz-prebuilt/Dockerfile
          - name: bootstrap
            context: build/bootstrap
            dockerfile: build/bootstrap/Dockerfile
          - name: search
            context: build/solr
            dockerfile: build/solr/Dockerfile
          - name: indexer
            context: build/sir
            dockerfile: build/sir/Dockerfile
          - name: mq
            context: build/rabbitmq
            dockerfile: build/rabbitmq/Dockerfile
          - name: assets
            context: .
            dockerfile: build/deploy-assets/Dockerfile
    steps:
      - uses: actions/checkout@v4
      - name: Validate channel input
        run: |
          set -e
          if [ "${{ inputs.channel }}" != "stable" ] && [ "${{ inputs.channel }}" != "test" ]; then
            echo "channel must be stable or test." >&2
            exit 1
          fi
      - name: Guard expected VERSION
        run: |
          set -e
          ACTUAL_VERSION=$(cat VERSION)
          if [ "$ACTUAL_VERSION" != "${{ inputs.expected_version }}" ]; then
            echo "VERSION mismatch: expected '${{ inputs.expected_version }}' but found '${ACTUAL_VERSION}'." >&2
            exit 1
          fi

      - name: Smoke check cron scripts
        run: |
          set -e
          grep -q "build_replication_schedule" build/musicbrainz/scripts/start.sh
          grep -q "build_replication_schedule" build/musicbrainz/scripts/load-crontab-only.sh
          grep -q "MUSICBRAINZ_INDEXING_" build/sir/scripts/indexer-cron.sh
          grep -q "indexer-reindex.sh" build/sir/scripts/indexer-cron.sh

      - name: Load build vars
      # shellcheck disable=SC1091
        run: |
          set -e
          USER_LC=$(echo "$DOCKERHUB_USERNAME" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAMESPACE=${USER_LC}" >> "$GITHUB_ENV"

          python3 - <<'PY' > /tmp/mbms_envvars
          from pathlib import Path

          env_path = Path(".env")
          if not env_path.exists():
            raise SystemExit(".env file not found.")

          values = {}
          for raw in env_path.read_text().splitlines():
            line = raw.strip()
            if not line or line.startswith("#"):
              continue
            if "=" not in raw:
              continue
            key, val = raw.split("=", 1)
            key = key.strip()
            val = val.strip()
            if (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
              val = val[1:-1]
            values[key] = val

          for key in (
            "POSTGRES_VERSION",
            "MB_SOLR_VERSION",
            "MUSICBRAINZ_SERVER_VERSION",
            "MUSICBRAINZ_BUILD_SEQUENCE",
          ):
            if key in values:
              print(f"{key}={values[key]}")
          PY
          while IFS= read -r line; do
            echo "$line" >> "$GITHUB_ENV"
            export "$line"
          done < /tmp/mbms_envvars

          python3 - <<'PY' >> "$GITHUB_ENV"
          import re
          from pathlib import Path

          version = Path("VERSION").read_text().strip()
          m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)(?:\.(\d{1,3}))?", version)
          if not m:
            raise SystemExit(f"VERSION format invalid: {version!r}")
          major, minor, release, _build = m.groups()
          tag = f"{major}.{minor}.{release}"
          print(f"DOCKER_TAG_VERSION={tag}")
          PY

          echo "POSTGRES_VERSION=$POSTGRES_VERSION" >> "$GITHUB_ENV"
          echo "MB_SOLR_VERSION=$MB_SOLR_VERSION" >> "$GITHUB_ENV"
          echo "MUSICBRAINZ_SERVER_VERSION=$MUSICBRAINZ_SERVER_VERSION" >> "$GITHUB_ENV"
          echo "MUSICBRAINZ_BUILD_SEQUENCE=$MUSICBRAINZ_BUILD_SEQUENCE" >> "$GITHUB_ENV"

          DB_BUILD_SEQUENCE=$(sed -n 's/^ARG DB_BUILD_SEQUENCE=//p' build/postgres-prebuilt/Dockerfile)
          echo "DB_BUILD_SEQUENCE=${DB_BUILD_SEQUENCE:-0}" >> "$GITHUB_ENV"

          SIR_VERSION=$(sed -n 's/^ARG SIR_VERSION=//p' build/sir/Dockerfile)
          PYTHON_VERSION=$(sed -n 's/^ARG PYTHON_VERSION=//p' build/sir/Dockerfile)
          BASE_IMAGE_DATE=$(sed -n 's/^ARG BASE_IMAGE_DATE=//p' build/sir/Dockerfile)
          echo "SIR_VERSION=$SIR_VERSION" >> "$GITHUB_ENV"
          echo "PYTHON_VERSION=$PYTHON_VERSION" >> "$GITHUB_ENV"
          echo "BASE_IMAGE_DATE=$BASE_IMAGE_DATE" >> "$GITHUB_ENV"

          RABBITMQ_VERSION=$(sed -n 's/^ARG RABBITMQ_VERSION=//p' build/rabbitmq/Dockerfile)
          RABBITMQ_VARIANT=$(sed -n 's/^ARG RABBITMQ_VARIANT=//p' build/rabbitmq/Dockerfile)
          RABBITMQ_TAG="${RABBITMQ_VERSION}${RABBITMQ_VARIANT}"
          echo "RABBITMQ_VERSION=$RABBITMQ_VERSION" >> "$GITHUB_ENV"
          echo "RABBITMQ_VARIANT=$RABBITMQ_VARIANT" >> "$GITHUB_ENV"
          echo "RABBITMQ_TAG=$RABBITMQ_TAG" >> "$GITHUB_ENV"

          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "SHORT_SHA=$SHORT_SHA" >> "$GITHUB_ENV"

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_MBMS }}

      - name: Compute tags and build args
        run: |
          set -e
          BUILD_ARGS=""
          case "${{ matrix.name }}" in
            db)
              VERSION="$POSTGRES_VERSION"
              BUILD_ARGS=$'POSTGRES_VERSION='"$POSTGRES_VERSION"$'\nDB_BUILD_SEQUENCE='"$DB_BUILD_SEQUENCE"
              ;;
            musicbrainz)
              VERSION="${MUSICBRAINZ_SERVER_VERSION}-build${MUSICBRAINZ_BUILD_SEQUENCE}"
              BUILD_ARGS=$'MUSICBRAINZ_SERVER_VERSION='"$MUSICBRAINZ_SERVER_VERSION"$'\nMUSICBRAINZ_BUILD_SEQUENCE='"$MUSICBRAINZ_BUILD_SEQUENCE"
              ;;
            bootstrap)
              VERSION="${MUSICBRAINZ_SERVER_VERSION}-build${MUSICBRAINZ_BUILD_SEQUENCE}"
              BUILD_ARGS=$'MUSICBRAINZ_SERVER_VERSION='"$MUSICBRAINZ_SERVER_VERSION"$'\nMUSICBRAINZ_BUILD_SEQUENCE='"$MUSICBRAINZ_BUILD_SEQUENCE"
              ;;
            search)
              VERSION="$MB_SOLR_VERSION"
              BUILD_ARGS=$'MB_SOLR_VERSION='"$MB_SOLR_VERSION"
              ;;
            indexer)
              VERSION="$SIR_VERSION"
              BUILD_ARGS=$'SIR_VERSION='"$SIR_VERSION"$'\nPYTHON_VERSION='"$PYTHON_VERSION"$'\nBASE_IMAGE_DATE='"$BASE_IMAGE_DATE"
              ;;
            mq)
              VERSION="$RABBITMQ_TAG"
              BUILD_ARGS=$'RABBITMQ_VERSION='"$RABBITMQ_VERSION"$'\nRABBITMQ_VARIANT='"$RABBITMQ_VARIANT"$'\nRABBITMQ_TAG='"$RABBITMQ_TAG"
              ;;
            assets)
              VERSION="$DOCKER_TAG_VERSION"
              ;;
            *)
              echo "Unknown image: ${{ matrix.name }}" >&2
              exit 1
              ;;
          esac

          TAGS="$IMAGE_REGISTRY/$IMAGE_NAMESPACE/${IMAGE_REPO_PREFIX}-${{ matrix.name }}:$DOCKER_TAG_VERSION"
          TAGS="$TAGS"$'\n'"$IMAGE_REGISTRY/$IMAGE_NAMESPACE/${IMAGE_REPO_PREFIX}-${{ matrix.name }}:$DOCKER_CHANNEL_TAG"

          printf "TAGS<<EOF\n%s\nEOF\n" "$TAGS" >> "$GITHUB_ENV"
          printf "BUILD_ARGS<<EOF\n%s\nEOF\n" "$BUILD_ARGS" >> "$GITHUB_ENV"

      - name: Build and push images
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64
          tags: ${{ env.TAGS }}
          build-args: ${{ env.BUILD_ARGS }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Compute Docker Hub description
        run: |
          set -e
          case "${{ matrix.name }}" in
            db)
              SHORT_DESC="Limbo (1 of 7): DB"
              README_FILE=".github/dockerhub/README-db.md"
              ;;
            musicbrainz)
              SHORT_DESC="Limbo (2 of 7): MusicBrainz"
              README_FILE=".github/dockerhub/README-musicbrainz.md"
              ;;
            bootstrap)
              SHORT_DESC="Limbo (3 of 7): Bootstrap"
              README_FILE=".github/dockerhub/README-bootstrap.md"
              ;;
            search)
              SHORT_DESC="Limbo (4 of 7): Search"
              README_FILE=".github/dockerhub/README-search.md"
              ;;
            indexer)
              SHORT_DESC="Limbo (5 of 7): Indexer"
              README_FILE=".github/dockerhub/README-indexer.md"
              ;;
            mq)
              SHORT_DESC="Limbo (6 of 7): MQ"
              README_FILE=".github/dockerhub/README-mq.md"
              ;;
            assets)
              SHORT_DESC="Limbo (7 of 7): Assets"
              README_FILE=".github/dockerhub/README-assets.md"
              ;;
            *)
              echo "Unknown image: ${{ matrix.name }}" >&2
              exit 1
              ;;
          esac

          echo "DOCKERHUB_REPO=${IMAGE_REPO_PREFIX}-${{ matrix.name }}" >> "$GITHUB_ENV"
          echo "SHORT_DESC=$SHORT_DESC" >> "$GITHUB_ENV"
          echo "README_FILE=$README_FILE" >> "$GITHUB_ENV"

      - name: Update Docker Hub description
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_MBMS }}
          repository: ${{ env.IMAGE_NAMESPACE }}/${{ env.DOCKERHUB_REPO }}
          short-description: ${{ env.SHORT_DESC }}
          readme-filepath: ${{ env.README_FILE }}

  publish-deploy:
    name: Publish Deploy Repo
    if: ${{ github.actor != 'github-actions[bot]' && (inputs.deploy_target == 'limbo' || inputs.deploy_target == 'both') }}
    runs-on: ubuntu-latest
    env:
      MBMS_TOKEN: ${{ secrets.MBMS_TOKEN }}
      DEPLOY_BRANCH: ${{ inputs.channel == 'test' && 'test' || 'main' }}
    steps:
      - uses: actions/checkout@v4
      - name: Validate channel input
        run: |
          set -e
          if [ "${{ inputs.channel }}" != "stable" ] && [ "${{ inputs.channel }}" != "test" ]; then
            echo "channel must be stable or test." >&2
            exit 1
          fi
          if [ "${{ inputs.deploy_target }}" != "limbo" ] && [ "${{ inputs.deploy_target }}" != "mbms" ] && [ "${{ inputs.deploy_target }}" != "both" ]; then
            echo "deploy_target must be limbo, mbms, or both." >&2
            exit 1
          fi
      - name: Guard expected VERSION
        run: |
          set -e
          ACTUAL_VERSION=$(cat VERSION)
          if [ "$ACTUAL_VERSION" != "${{ inputs.expected_version }}" ]; then
            echo "VERSION mismatch: expected '${{ inputs.expected_version }}' but found '${ACTUAL_VERSION}'." >&2
            exit 1
          fi

      - name: Load deploy vars
      # shellcheck disable=SC1091
        run: |
          set -e
          CHANNEL="${{ inputs.channel }}"
          python3 - <<'PY' >> "$GITHUB_ENV"
          import os
          import re
          from pathlib import Path

          version = Path("VERSION").read_text().strip()
          m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)(?:\.(\d{1,3}))?", version)
          if not m:
            raise SystemExit(f"VERSION format invalid: {version!r}")
          major, minor, release, build_str = m.groups()
          build_str = build_str or "0"
          version_full = f"{major}.{minor}.{release}.{build_str}"
          release_version_3 = f"{major}.{minor}.{release}"
          channel = os.environ.get("CHANNEL", "stable")
          if channel == "test":
            tag_version = f"{major}.{minor}.{release}.{build_str}"
            release_version = tag_version
          else:
            tag_version = release_version_3
            release_version = release_version_3
          print(f"MBMS_TAG_VERSION={tag_version}")
          print(f"MBMS_VERSION_FULL={version_full}")
          print(f"RELEASE_VERSION={release_version}")
          PY

      - name: Checkout deploy repo
        uses: actions/checkout@v4
        with:
          repository: HVR88/Limbo
          token: ${{ secrets.MBMS_TOKEN }}
          ref: ${{ env.DEPLOY_BRANCH }}
          path: deploy

      - name: Stage deploy files
        run: |
          set -e
          rm -rf deploy-out
          mkdir -p deploy-out

          cp deploy-assets/docker-compose.yml deploy-out/docker-compose.yml
          cp deploy-assets/README.md deploy-out/README.md
          cp deploy-assets/example.env deploy-out/example.env
          echo "$MBMS_VERSION_FULL" > deploy-out/VERSION

          python3 - <<'PY'
          from __future__ import annotations

          import os
          from pathlib import Path

          env_path = Path("deploy-out/example.env")
          text = env_path.read_text()
          lines = text.splitlines()

          def upsert(lines: list[str], key: str, value: str) -> list[str]:
            out: list[str] = []
            found = False
            prefix = f"{key}="
            for line in lines:
              if line.startswith(prefix):
                out.append(prefix + value)
                found = True
              else:
                out.append(line)
            if not found:
              out.append(prefix + value)
            return out

          lines = upsert(lines, "MBMS_DOCKERHUB_NAMESPACE", "espressomatic")
          lines = upsert(lines, "MBMS_DOCKERHUB_REPO_PREFIX", "limbo")

          env_path.write_text("\n".join(lines).rstrip() + "\n")
          PY

      - name: Sync deploy repo
        run: |
          set -e
          rsync -a --delete --exclude .git deploy-out/ deploy/

      - name: Create release zip
        if: ${{ inputs.channel == 'stable' }}
        run: |
          set -e
          ZIP_NAME="limbo-${RELEASE_VERSION}.zip"
          rm -f "$ZIP_NAME"
          (cd deploy-out && zip -r "../$ZIP_NAME" .)
          echo "DEPLOY_ZIP_NAME=$ZIP_NAME" >> "$GITHUB_ENV"

      - name: Commit and push
        working-directory: deploy
        run: |
          set -e
          if [ -z "$(git status --porcelain)" ]; then
            echo "No deploy changes to publish."
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "Publish deploy files from ${GITHUB_REPOSITORY}@${GITHUB_SHA}"
            git push origin "${DEPLOY_BRANCH}"
          fi

      - name: Tag and release deploy repo
        working-directory: deploy
        if: ${{ inputs.channel == 'stable' }}
        env:
          GH_TOKEN: ${{ secrets.MBMS_TOKEN }}
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TAG="v${RELEASE_VERSION}"
          echo "TAG_VERSION=$TAG" >> "$GITHUB_ENV"

          git fetch --tags
          if ! git rev-parse "$TAG" >/dev/null 2>&1; then
            git tag -a "$TAG" -m "Limbo ${RELEASE_VERSION}"
            git push origin "$TAG"
          fi

          if ! gh release view "$TAG" -R HVR88/Limbo >/dev/null 2>&1; then
            gh release create "$TAG" -R HVR88/Limbo -t "Limbo" -n "Automated release."
          fi

          gh release upload "$TAG" -R HVR88/Limbo "../${DEPLOY_ZIP_NAME}" --clobber

  publish-deploy-mbms:
    name: Publish Deploy Repo (MusicBrainz-MBMS)
    if: ${{ github.actor != 'github-actions[bot]' && (inputs.deploy_target == 'mbms' || inputs.deploy_target == 'both') }}
    runs-on: ubuntu-latest
    env:
      MBMS_TOKEN: ${{ secrets.MBMS_TOKEN }}
      DEPLOY_BRANCH: ${{ inputs.channel == 'test' && 'test' || 'main' }}
    steps:
      - uses: actions/checkout@v4
      - name: Validate channel input
        run: |
          set -e
          if [ "${{ inputs.channel }}" != "stable" ] && [ "${{ inputs.channel }}" != "test" ]; then
            echo "channel must be stable or test." >&2
            exit 1
          fi
          if [ "${{ inputs.deploy_target }}" != "limbo" ] && [ "${{ inputs.deploy_target }}" != "mbms" ] && [ "${{ inputs.deploy_target }}" != "both" ]; then
            echo "deploy_target must be limbo, mbms, or both." >&2
            exit 1
          fi
      - name: Guard expected VERSION
        run: |
          set -e
          ACTUAL_VERSION=$(cat VERSION)
          if [ "$ACTUAL_VERSION" != "${{ inputs.expected_version }}" ]; then
            echo "VERSION mismatch: expected '${{ inputs.expected_version }}' but found '${ACTUAL_VERSION}'." >&2
            exit 1
          fi

      - name: Load deploy vars
      # shellcheck disable=SC1091
        run: |
          set -e
          CHANNEL="${{ inputs.channel }}"
          python3 - <<'PY' >> "$GITHUB_ENV"
          import os
          import re
          from pathlib import Path

          version = Path("VERSION").read_text().strip()
          m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)(?:\.(\d{1,3}))?", version)
          if not m:
            raise SystemExit(f"VERSION format invalid: {version!r}")
          major, minor, release, build_str = m.groups()
          build_str = build_str or "0"
          version_full = f"{major}.{minor}.{release}.{build_str}"
          release_version_3 = f"{major}.{minor}.{release}"
          channel = os.environ.get("CHANNEL", "stable")
          if channel == "test":
            tag_version = f"{major}.{minor}.{release}.{build_str}"
            release_version = tag_version
          else:
            tag_version = release_version_3
            release_version = release_version_3
          print(f"MBMS_TAG_VERSION={tag_version}")
          print(f"MBMS_VERSION_FULL={version_full}")
          print(f"RELEASE_VERSION={release_version}")
          PY

      - name: Checkout deploy repo
        uses: actions/checkout@v4
        with:
          repository: HVR88/MusicBrainz-MBMS
          token: ${{ secrets.MBMS_TOKEN }}
          ref: ${{ env.DEPLOY_BRANCH }}
          path: deploy

      - name: Stage deploy files
        run: |
          set -e
          rm -rf deploy-out
          mkdir -p deploy-out

          cp deploy-assets/docker-compose.mbms.yml deploy-out/docker-compose.yml
          cp deploy-assets/README.mbms.md deploy-out/README.md
          cp deploy-assets/example.mbms.env deploy-out/example.env
          echo "$MBMS_VERSION_FULL" > deploy-out/VERSION

          python3 - <<'PY'
          from __future__ import annotations

          import os
          from pathlib import Path

          env_path = Path("deploy-out/example.env")
          text = env_path.read_text()
          lines = text.splitlines()

          def upsert(lines: list[str], key: str, value: str) -> list[str]:
            out: list[str] = []
            found = False
            prefix = f"{key}="
            for line in lines:
              if line.startswith(prefix):
                out.append(prefix + value)
                found = True
              else:
                out.append(line)
            if not found:
              out.append(prefix + value)
            return out

          lines = upsert(lines, "MBMS_DOCKERHUB_NAMESPACE", "espressomatic")
          lines = upsert(lines, "MBMS_DOCKERHUB_REPO_PREFIX", "limbo")

          env_path.write_text("\n".join(lines).rstrip() + "\n")
          PY

      - name: Sync deploy repo
        run: |
          set -e
          rsync -a --delete --exclude .git deploy-out/ deploy/

      - name: Create release zip
        if: ${{ inputs.channel == 'stable' }}
        run: |
          set -e
          ZIP_NAME="musicbrainz-mbms-${RELEASE_VERSION}.zip"
          rm -f "$ZIP_NAME"
          (cd deploy-out && zip -r "../$ZIP_NAME" .)
          echo "DEPLOY_ZIP_NAME=$ZIP_NAME" >> "$GITHUB_ENV"

      - name: Commit and push
        working-directory: deploy
        run: |
          set -e
          if [ -z "$(git status --porcelain)" ]; then
            echo "No deploy changes to publish."
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "Publish deploy files from ${GITHUB_REPOSITORY}@${GITHUB_SHA}"
            git push origin "${DEPLOY_BRANCH}"
          fi

      - name: Tag and release deploy repo
        working-directory: deploy
        if: ${{ inputs.channel == 'stable' }}
        env:
          GH_TOKEN: ${{ secrets.MBMS_TOKEN }}
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TAG="v${RELEASE_VERSION}"
          echo "TAG_VERSION=$TAG" >> "$GITHUB_ENV"

          git fetch --tags
          if ! git rev-parse "$TAG" >/dev/null 2>&1; then
            git tag -a "$TAG" -m "MusicBrainz-MBMS ${RELEASE_VERSION}"
            git push origin "$TAG"
          fi

          if ! gh release view "$TAG" -R HVR88/MusicBrainz-MBMS >/dev/null 2>&1; then
            gh release create "$TAG" -R HVR88/MusicBrainz-MBMS -t "MusicBrainz-MBMS" -n "Automated release."
          fi

          gh release upload "$TAG" -R HVR88/MusicBrainz-MBMS "../${DEPLOY_ZIP_NAME}" --clobber

  release:
    name: Tag Release and Bump Minor
    needs:
      - publish-dockerhub
      - publish-deploy
      - publish-deploy-mbms
    if: >-
      ${{ github.actor != 'github-actions[bot]'
          && needs.publish-dockerhub.result == 'success'
          && needs.publish-deploy.result != 'failure'
          && needs.publish-deploy-mbms.result != 'failure' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate channel input
        run: |
          set -e
          if [ "${{ inputs.channel }}" != "stable" ] && [ "${{ inputs.channel }}" != "test" ]; then
            echo "channel must be stable or test." >&2
            exit 1
          fi
      - name: Guard expected VERSION
        run: |
          set -e
          ACTUAL_VERSION=$(cat VERSION)
          if [ "$ACTUAL_VERSION" != "${{ inputs.expected_version }}" ]; then
            echo "VERSION mismatch: expected '${{ inputs.expected_version }}' but found '${ACTUAL_VERSION}'." >&2
            exit 1
          fi

      - name: Tag release
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          CHANNEL="${{ inputs.channel }}"
          RELEASE_VERSION=$(python3 - <<'PY'
          import os
          import re
          from pathlib import Path

          version = Path("VERSION").read_text().strip()
          m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)(?:\.(\d{1,3}))?", version)
          if not m:
            raise SystemExit(f"VERSION format invalid: {version!r}")
          major, minor, release, build = m.groups()
          build = build or "0"
          release_version_3 = f"{major}.{minor}.{release}"
          channel = os.environ.get("CHANNEL", "stable")
          if channel == "test":
            print(f"{major}.{minor}.{release}.{build}")
          else:
            print(release_version_3)
          PY
          )
          git fetch --tags
          if [ "${{ inputs.channel }}" = "test" ]; then
            TAG="test-v${RELEASE_VERSION}"
          else
            TAG="v${RELEASE_VERSION}"
          fi
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists."
            exit 0
          fi
          git tag -a "$TAG" -m "Release ${RELEASE_VERSION}"
          git push origin "$TAG"
